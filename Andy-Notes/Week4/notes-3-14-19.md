# Notes 3-14-19
DOCKERS

## Extras
- azure devops: Organization settings, can check retention and parallel settings
	- check minutes used up and free status etc
- [Install docker toolbox](https://docs.docker.com/toolbox/toolbox_install_windows/)
	- we run our docker in a Linux VM when we start the app
- https://hub.docker.com/_/microsoft-dotnet-core where we can get docker images to pull


## Docker (self notes)
- https://docs.microsoft.com/en-us/dotnet/standard/containerized-lifecycle-architecture/
- **Containerization** approach in sw dev in which an app or service, its dependencies and configs are packaged together as a container image.
	- can test that containerized app as a unit and delpoy as a container image instance to the OS
	- allows devs and IT to deploy across env with little or no mods
	- containers isolate apps from each other on shared OS
		- run on top of container host that then runs on OS 
		- faller footprints than a VM image
	- scalability: scale out quickly by creating new containers for short term tasks
	- summary: isolation, portability, agility, scalability, and control across app lifecycle workflow
- Open sourced project for automating delpoyment of apps as portabl, self-sufficient containers that run on cloud or on-premises
- comparison between VMs and Docker Containers
	- ![Comparison for VMs and Docker containers](https://docs.microsoft.com/en-us/dotnet/standard/containerized-lifecycle-architecture/media/image3.png "vms vs docker")
- **container image**: package with dep and info needed to create a container
	- image includes all dep (e.g. frameworks) + deployment and execution fonfigs used by container runtime
	- immutable once created
- **container**: instance of a Docker image
	- image is a static representation of the app or service and its config and dependencies
		- store images in a registry that acts as a library of images
	- represents execution of a single app, procss or service.
	- contains content of docker image, exec env, and set of instructions
	- when scaling project you create multiple instances of a container from same image
- ![Docker app life cycle](https://docs.microsoft.com/en-us/dotnet/standard/containerized-lifecycle-architecture/docker-application-lifecycle/media/image2.png)

## Virtualization
- single boot: `[[Apps][apps][apps] dep]->[OS]->[hardware]`
	- no virtualization
- dual boot: has two OS to switch between (Ubuntu represents!) 
	- no virtualization
- OS-level virtualization: `[guest os [apps][dep]] [guest os [apps][dep]] -> [Hypervisor[apps][apps]] -> [host OS] -> [Hardware]`
	- top two guest os with apps are virtual machines
	- Hypervisor is generally VirtualBox and VMWare
		- expose VB hardware interface to gues OSes and connect that to real hardware in host OS
		- just a big file that won't use any resources when you turn image off
	- when you start a VM you most allocate fixed blocks of RAM
	- use over containers if you want to do Linux stuffs
- containers: `[container engine [app][dep] + [app][dep]..] -> [OS] -> [Hardware]`
	- dependencies like NuGet and .NET Core runtime packages found in container engine shard to each of those [dep]
		- need just one dep in one place and it applies to all apps (all apps isolated from one another)
	- flexibly use resources like memory in same way as regular processes
	- more granular when creating many instances within container
	- faster to set up compared to VM
	- bit more of a learning curve compared to VMs

## Use Docker
- if we had windows professional or linux, we can install real Docker
	- but non-pro windows 10 doesnt support containers (yet?) so we use *Docker Toolbox*
- Docker toolbox is meant to be one click set up for running Linux containers on Windows using small linux VM
- [Docker Engine [Docker CLI (Client(Docker CLI))]  <--REST API--> [Docker Toolbox (server(server daemon))]]
- can use regular command with `docker-machine start`
	- `docker-machine stop` to stop
- images are built in layers
- Docker Client speaks to a Docker daemon which pulls an image from the Docker Hub
	- then the daemon creates a new container from image which runs executable that produces output
	- Docker daemon streamed that output to Docker client, which can be sent to terminal
- docker commands
	- `docker run <image-name>`
		- this starts a new container from the given image (downloading image if necessary)
	- `docker pull <image-name>`
		- just downloads the image (updates if new version)
- docker image:
	- template for container to start
	- has whole file sys
	- has pointer to some program inside the image that should run when we start container
	- images are **layered** - every image has some base image with new layers added on top
- Dockerfile
	- provides instructions to build a new image from some base image
	- FROM: 
		- Set the baseImage to use for subsequent instructions. FROM must be the first instruction in a Dockerfile
		- sets the base image to use for subsequent layers
	- COPY:
		- Copy files or folders from source to the dest path in the image's filesystem.
	- CMD:
		- what to run when we start the container
	- other commands used
		- `winpty docker pull mcr.microsoft.com/dotnet/core/sdk:2.2`
			- winpty used for windows to displays download nicely
	- `docker-machine ip` : finds our ip
	- `docker rm a96` to remove a container
	- `docker container ls` lists out containers
		- ls -a for everything
	- `docker logs someNumberForProject`

**Check out nick's notes for the missing parts**
- Orchestration
	- Docker Swarm
	- Kubernetics
