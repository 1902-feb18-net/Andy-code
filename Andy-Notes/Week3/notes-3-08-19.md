# revature 3-08-19

## More MVC stuffs
- ways to get data from the controller to the view
	1. strongly typed view the model
		- often will be a view model
		- view can only take one model, so if you need several
			- either that's a collection type of some kind or
			- make a new view model that contains the several you need
	2. ViewData - a key-value pair dictionary
		- this obj is reachable via a property on Controller
		- can assign values in controller and access in the view
		- (during the same HTTP request! It's cleared between requests)
		- Designed around request response, ViewData disappears betweens requests
		- e.g. `ViewData["numOfMovies"] = viewModel.Count;`
			- then within some view we use like this, relying on this not as good
			- `<h4>Num of movie: @ViewData["numOfMovies"]</h4>`
	3. e.g. `ViewBag.numOfMovies = viewModel.Count`
		- `<h4>Num of movie: @ViewBag.numOfMovies</h4>`
		- **ViewBag** a different way to access ViewData = "dynamic" type.
			- set properties instead of using indexing syntax w/ string.
			- an obj whose operations will be resolved at runtime
			- dynamic type - compile time type checking turned off
				- we can add new props to that obj at any time
	4. TempData - a K V pair dictionary
		- the value inside it survives across req "magically"
		- by default stored using cookies sent to the client
		- which are then sent back to server on subsequent req
			- but we can configure other providers for TempData in Startup
		- e.g. we can use this to incrementally build some model
			- needing many forms to be submitted, not just one
		- with regular ["key"] access, the value you access gets deleted.
			- only after the current request, circumvent with methods 
				- .Peek("key")
					- access value w/o marking for deletion
				- .Keep("key")
					- unmarks a value for deletion
		- 	```html
			<h4>Counter (with TempData): @TempData["counter"]</h4>
			@{
				if((int)TempData["counter"] <= 3)
				{
					TempData.Keep("counter");
				}
			}
			@{
				// within controller
				if(TempData.ContainsKey("counter"))
				{
					TempData["counter"] = ((int)TempData["counter"]) + 1;
				} 
				else
				{
					TempData["counter"] = 0;
				}
			}
			```
		- the other way we can keep data around to incrementally build something like
			- an order is with hidden form fields
		- 	```cshtml
			<form asp-action="Post">
			@for(int i = 0; i< Model.Count; i++)
			{
				@Html.Hidden($"[{i}].Id", Model[i].id)
			}
			<input type = "submit" value="Post" class="btn btn-default"/>
			</form>
			```
- attributes
	- routing in contrast to global/convention based routing
		- e.g. `[/{num:int?}]`
			- this skips initial controller part with /
		- e.g. `[index/{num:int?}]`
			- allows us to input some route param (to counter for e.g.)
		- e.g. `[Route("[controller]/asdfasdf/ShowAllMovies")]`
		- `public ActionResult Index([FromQuery] int num){}`
			- prev method won't work, but if you include `?` query string for num, it will work
			- fix previous ambiguous routes with `Route["Films/[action]"]`
			- we have [FromQuery] to get that param from query string ("?key=val" in URL)
			- we have [FromForm]/[FromBody] to get it from a form submission
			- we have [FromRoute] to get it from route params (defined in attr or global route)
			- we have [FromServices] to ask for some service exactly like constructor params do
- strategy for unit testing controllers
	



