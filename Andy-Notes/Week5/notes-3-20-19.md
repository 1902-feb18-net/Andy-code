# 3-20-19 notes
note: 
res = response
req = request
doc = document
desc = description

## [REST reading](https://martinfowler.com/articles/richardsonMaturityModel.html)
![Glory of REST](https://martinfowler.com/articles/images/richardsonMaturityModel/overview.png "rest image")

### Level 0
- usage of HTTP as transport system for remote interactions 
	- not using any mech. from web
	- usually through [Remote Procedure Invocation](https://www.enterpriseintegrationpatterns.com/patterns/messaging/EncapsulatedSynchronousIntegration.html)
- e.g. a hospital expose service endpoint at some URI and I post to the endpoint containing details of my reservation request
	- sends response of 200 OK back if good

### Level 1 - Resources
- we start talking to individual resources
- notion of object identity
	- call a method on one particular object providing arguments for the other information.
- e.g. we might have individual doctors

### Level 2 - HTTP Verbs
- We use HTTP verbs as closely as possible
- GET is defined as a safe operation
	- allows participants in routing of req. to use caching
- If using POST, could get a code 201 to show that there's a new resource
	- location attribute with URI
- 409 would be if someone update res in an incompatible way 
- strong separation between safe (eg GET) and non-safe operations, together with using status codes to help communicate the kinds of errors you run into

### Level 3 - Hypermedia Controls
- HATEOAS (Hypertext As The Engine Of Application State)
- e.g. address how to get from list open slots to knowing what to do to book an appointment
- hypermedia controls tells us what we can do next
	- URI of res we need to manipulate to do it
- benefits
	- allows server to change its URI scheme w/o breaking clients
	- helps client dev explore the protocol
		- gives a hint to what may be possible next
	- advertise new capabilities by putting new links in the res

### Summary
- Level 1 tackles the question of handling complexity by using divide and conquer, breaking a large service endpoint down into multiple resources.
- Level 2 introduces a standard set of verbs so that we handle similar situations in the same way, removing unnecessary variation.
- Level 3 introduces discoverability, providing a way of making a protocol more self-documenting.
- As Ben said: Spot -> See Spot -> See Spot Run -> Run Spot Run

## SOAP, RPC, REST, and etc
- SOAP
	- message goes in POST req, in the body
	- protocol communicates using XML over a variety of transport protocol
		- rigorously define all needed info about service in a WSDL doc
- RPC 
	- "service.com/methodName?param1=23"
	- calling a method with params from URI
- HTTP 
	- has a lot of semantics that traditionally
		- websites implement partly 
			- GET for read, POST for write
			- and web services (SOAP, RPC)
				- ignore
		- REST follows HTTP semantics
- REST
	- representional state transfer
	- an architecture
	- communicates using many representations 
		- often JSON
		- over HTTP only
	- info of service either:
		1. not rigorously defined 
			- not really REST
		2. hypermedia/HATEOAS (110% REST)
			- next level after SOA
			- service itself evolves on runtime, where devs discovers new routes
		3. one of many API desc. lang.
			- like WSDL for SOAP
			-  e.g. OpenAPI/Swagger, API Blueprint
	- payoffs:
		- layered arch: payoff in 1 year
		- SOA: payoff in 3 years
		- hypermedia: payoff in 15 years

## REST Principles
- **uniform interface**
	- *use HTTP semantically(according to proper meaning)* ~~heavy breathing sounds~~
		- in headers, method, and status code
	- identify res. 
		- have 1-to-1 relationships between URLs and res
	- distinguish res from its representations
- **client-server architecture**
	- make sure there is a client server separation, only the things he exposes
- **statelessness**
	- server is not going to store any state about the exchanges with the client
	- per req. stuff should not be stored in the server (no partial stuffs)
	- client is the one responsible to sending everything the server needs for the req
- **cacheability**
	- when http allows it, we should be able to cache res
	- if same req comes in, there should be the same res coming back
	- more we can cache, more we can scale up
- **layered system**
	- might be a number of servers in the middle. 
	- These servers might provide a security layer, a caching layer, a load-balancing layer, or other functionality. 
	- Those layers should not affect the request or the response.
- **code on demand**
	- optional
	- a client could req from server
	- response from the server will contain some code, usually in the form of a script, 
		- when the response is in HTML format. The client then can execute that code.