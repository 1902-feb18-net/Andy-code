# Revature Notes for 2/28/19

## SQL stuffs!
- Multiplicity
	- 1 to 1 	-> 1 table, or 2 tables, FK UNIQUE
	- 1 to N 	-> 2 tables - FK NOT NULL
	- 0/1 to N 	-> 2 tables FK NULL
	- N to N 	-> 3 tables, the middle one "junction table", "join table" with 2 FK
		- both going away from junction table
- **transaction**
	- a sequence of operations performed (using one or more SQL statements) on a database as a single logical unit of work
	- every statment is a transaction
	- **ACID**
		- A: *atomic*, all operations succeed 100% or do nothing at all 
		- C: *consistent*, operations should not be allowed to violate constraints
		- I: *isolated*, even if multiple transactions run concurrently, it should be AS IF each was running along (transactions shouldn't interfere with each other)
		- D: *durable*, transactions incomplete until written to persistent storage (written to hard disk in some fashion)
		- e.g. `INSERT INTO Table VALUE; (   ), (   ), ( ERROR (~~~))`
			- SELECT: check account balance, UPDATE: withdraw funds, UPDATE: deposit in other account
	- From Table 1, higher up is more performance, further down is more isolation
	- Multi statement transaction
		- BEGIN TRANSACTION
			- U
			- U  IF ~
			- S  	ROLLBACK TRANSACTION
		- COMMIT TRANSACTION; 

### Tables

| Issue                                                                                    | Isolation level that fixes issue  |
|------------------------------------------------------------------------------------------|-----------------------------------|
|                                                                                          | read_uncommitted                  |
| dirty read (see other transactions unfinished work)                                      | read_committed (default)          |
| nonrepeatable read (read row twice, another finished transaction changed it in between)  | repeatable_read                   |
| Phantom read (other transactions can insert  rows that meet conditions I'm filtering on) | serializable                      |

## SQL in VISUAL STUDIOS
- install in nuget System.Data.SqlClient
- in case [Forgot connections](https://www.connectionstrings.com/)
	- in our case [Azure](https://www.connectionstrings.com/sql-azure/)
- remember to use .gitignore for the class we're using for our private informations

## Other SQL:
- object relational impedance mismatch
- object relational mapper
	- Java: Hibernate
	- .NET has Identity Framework (IF)
	- NHibernate, Dapper
- currently at Entity framework 6
	- .NET framework: EF6
	- .NET Core EF Core 2.2
		- lazy loading
		- many to many without a class for the junction table
	- Fluent API(Application program interface): where the result is formulated by method chaining.
		- method chaining: is a common syntax for invoking multiple method calls in object-oriented programming languages. Each method returns an object, allowing the calls to be chained together in a single statement without requiring variables to store the intermediate results
- database-first
- code genration, and scaffolding
- when ref. integrity would be violated
	- delete
	- update
	- we can handle in 3 ways
		1. (default) raise error
		2. cascade (e.g. c -> i -> isomething and you delete c, it'll get rid of the whole thing)
		3. set null (requires a nullable column)

## Entity Framework Setting up:
- EF DB first approach steps
	1. have startup project and data access library project
	2. reference data access from startup project
	3. add NuGet packages to startup project
		- Microsoft.EntityFrameworkCore.Tools
		- Microsoft.EntityFrameworkCore.SqlServer
		- and to the data access project
			- Microsoft.EntityFrameworkCore.SqlServer
	4. Open package manager Console in VS
		-  (view -> other windows -> package manager console)
		-  (alternate 4/5. run in git bash)
			- `dotnet ef dbcontext scaffolf "<your connection string>"`
			- `Microsoft.EntityFrameworkCore.SqlServer`
           	- `--project <name of data project>`
	5. Run command
		- `Scaffold-DBContext "<your-connection-string>" Microsoft.EntityFrameworkCore.SqlServer -Project <name-of-data-project>` (-Force if necessary)
	6. Delete the OnConfiguring ovverride in the DbContext, to prevent
		- committing your connection string to git.- 
	7. any time we change the DB (add a new col etc...), go to step 4
		- by default the scaffolding will configure the models in OnModelCreating
-  with the fluent API, this is the right way to do it - strongest separation of concerns
- if we scaffold with option "-DataAnnotations" (/"--data-annotations") we'll put the configs on the Movie
	- and Genre classes themselves with attributes
- 3rd way to configure is convention based
- Async
	- where any returns concrete values, we would apply async at end of those
		- start from bottom to top
	- read -> EF provides async extensions to LINQ
		- e.g. toList() would have async version and many others
	- write -> SaveChangesAsync


## Project 0
- wants interfaces for the repositories
	- can have one repository for everything
	- or split into multiple classes
		- e.g. OrderRepo, LocationRepo